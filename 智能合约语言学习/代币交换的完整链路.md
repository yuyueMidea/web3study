下面把 代币交换的完整链路 梳理一遍，并把关键的方法swap，从‘入参到落链’每一步拆开说明。（包含状态流转、何时授权、三种交换分支、常见坑位和调换示例）

总览：角色 & 状态
- 合约实例：router = useRouterContract(true)（DEX 路由）；useERC20Contract(addr, true)（需要写操作的 ERC20 实例）。
- 地址集：addresses.ROUTER 和 addresses.WETH 来自 useContractAddresses()。
- 统一工具：parseTokenAmount（把可读金额→Wei）、getDeadline、waitForTransaction（等确认）、parseError（提炼报错）。
- 状态位：loading（整套流程中）、approving、swapping、error、txHash。它们在授权与交换两个阶段分别置位/清理。

**顶层入口：swap(params) 的完整流程**
```
await swap({
  inputToken,       // 输入代币地址（原生币用 isNativeToken 判）
  outputToken,      // 输出代币地址
  inputAmount,      // 字符串，如 "1.23"
  minimumOutput,    // 经过滑点后的最小可得（Wei，或外部先算好）
  inputDecimals,    // 输入代币小数位，默认 18
  path,             // 可选，自定义路径；不传则按 ETH/WETH 规则自动构建
  deadlineMinutes,  // 可选，默认 20
  onSuccess, onError
})
```

执行顺序（同步到状态）：
- setLoading(true)。
- 如输入不是原生币：先算 amountIn = parseTokenAmount(inputAmount, inputDecimals)，并调用 approveToken(inputToken, amountIn, ...)。若授权额度已足够，会直接跳过链上授权；否则发起 approve 并等确认。
- 授权完成后，进入 executeSwap(params) 做智能分发：
   - isNativeToken(inputToken) ⇒ swapETHForTokens
   - isNativeToken(outputToken) ⇒ swapTokensForETH
   - 否则 ⇒ swapTokensForTokens。

- 对应分支里发起 swapExact... 交易，保存 txHash，waitForTransaction 等确认，成功回调 onSuccess({hash, receipt}) 并清空 txHash、setSwapping(false)；最终 setLoading(false)。

小结：swap 只负责一键式编排（必要时先授权，再按类型路由到具体交换函数），而真正与链交互的是 approveToken + 三个 swapXxx。

**阶段一：授权 approveToken(token, amountIn, onSuccess, onError)**
- 短路条件：账号未连、router 未就绪、或 isNativeToken(token)（原生币不需要授权）⇒ 直接 return。
- 拿 ERC20 合约：const tokenContract = await useERC20Contract(tokenAddress, true)；这里用 await 拿到“可写”实例。
- 查当前授权：allowance(account, addresses.ROUTER)；若 currentAllowance >= amountIn，直接跳过授权流程（approving=false，回调 onSuccess()）。
- 发起授权：approve(addresses.ROUTER, amountIn) → 记录 txHash → waitForTransaction。失败时将错误通过 parseError 人性化后回传。
- 提示：用的是 bignumber.js 做额度比较（把合约返回值转字符串后比较），避免精度/类型不一致。

**阶段二：三种交换分支（均会 setSwapping(true) → 交易哈希 → 等确认）**
- 1) Token → Token：swapTokensForTokens
   - 关键入参：inputToken、outputToken、inputAmount、minimumOutput、inputDecimals。
   - 金额：amountIn = parseTokenAmount(inputAmount, inputDecimals)。
   - 路径：缺省用 [inputToken, outputToken]；也支持自定义 path。
   - deadline：getDeadline(deadlineMinutes)。
   - 交易：router.swapExactTokensForTokens(amountIn, minimumOutput, path, account, deadline)。

- 2) ETH → Token：swapETHForTokens
   - 金额：视为 18 位，amountIn = parseTokenAmount(inputAmount, 18)。
   - 路径：缺省 [addresses.WETH, outputToken]（路由器侧是 WETH 入场）。
   - 交易：router.swapExactETHForTokens(minimumOutput, path, account, deadline, { value: amountIn })。

- 3) Token → ETH：swapTokensForETH
   - 金额：amountIn = parseTokenAmount(inputAmount, inputDecimals)。
   - 路径：缺省 [inputToken, addresses.WETH]（WETH 出口由路由器 unwrap）。
   - 交易：router.swapExactTokensForETH(amountIn, minimumOutput, path, account, deadline)。
   - 三者成功后都会：setTxHash(swapTx.hash) → waitForTransaction(swapTx) → setSwapping(false)、setTxHash(null) → 回调 onSuccess({hash, receipt})。失败则进入 catch，做 parseError、setError(errorMsg) 并抛出。

**智能选择器：executeSwap(params)**
- 根据 isNativeToken(inputToken) / isNativeToken(outputToken) 自动选分支；否则默认走 Token→Token。对外屏蔽了三种细节差异。
