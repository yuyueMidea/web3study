- **什么是重入攻击，它是如何在智能合约中执行的？**

重入攻击（Reentrancy Attack）是智能合约中的一种安全漏洞，攻击者利用合约对外部调用的处理缺陷，在未完成当前交易前重复调用合约函数，从而恶意提取资金或篡改状态；攻击执行的方式：漏洞条件（合约先更新内部状态再发送资金，未使用防重入锁 如nonReentrant 修饰符）、攻击步骤（攻击者部署恶意合约，在fallback/receive函数中，递归调用受害合约的提款函数；受害合约未更新余额前，攻击者重复提款，直到耗尽合约资金）；核心风险：任何外部调用都可能触发重入，需严格审查合约逻辑。

- **如何防止智能合约中的重入攻击？**

防止智能合约中的重入攻击，核心是阻断恶意递归调用，主要包括以下方法：1、状态优先原则（严格遵循Checks-Effects-Interactions模式,比如转账前先扣除余额，再执行转账操作）；2、重入锁机制（使用OpenZeppelin的ReentrancyGuard合约 或自定义修饰器）；3、安全转账方式（优先使用transfer，避免使用call.value()d的低级调用）；4、特殊场景保护（对回调函数进行限制，复杂业务中设置执行状态检查点）；以上这些措施能有效阻断恶意合约通过fallback函数发起的递归攻击，保障资金安全。

- **DAO攻击是如何发生的，它与重入漏洞有什么关系？**

The DAO是一个去中心化自治组织，用户可存入ETH以获取DAO代币，并通过投票决定资金用途，包括以下核心功能：存款（用户存入ETH，获得DAO代币）提款（用户可取回ETH收益）；2016年发生的The DAO攻击是区块链历史上最著名的安全性事件之一，攻击者利用智能合约的重入漏洞，盗取ETH，最终导致以太坊硬分叉（诞生ETC和ETH）；漏洞代码分析是关键问题出在提款函数的逻辑顺序（漏洞点是先转账后更新状态），攻击者部署了一个恶意合约其核心逻辑是正常调用withdrawRewardFor 提款,并在恶意合约的fallback中递归调用withdrawRewardFor ，循环提款；DAO攻击是最典型的重入攻击案例，其核心问题是：外部调用风险（使用call.value()允许目标合约执行代码），状态更新滞后（未在转账前标记“已提款”导致状态不一致）；总结：DAO攻击是重入漏洞的教科书级案例，它测地改变了智能合约的安全开发范式，推动了对状态管理和外部调用的严格规范。

- **什么是整数溢出和下溢，它们如何影响智能合约？**

在智能合约中，整数溢出是指变量的值超过其类型的最大值（如uint8最大为255，若255 +1=0），下溢是指值低于最小值（如uint8的 0-1=255）；对智能合约有以下影响：资金计算错误（余额检查失效，如攻击者下溢使balance=0-1，获得巨额代币）；逻辑漏洞（条件判断被绕过，如require（balance>0）因溢出返回true）；总结：溢出/下溢会直接破坏合约逻辑，必须通过语言特性或库强制防护。

- **如何在solidity合约中防止整数溢出和下溢？**

在solidity合约中防止整数溢出（Overflow）和下溢（Underflow）的方法如下：1、使用Solidity 0.8+ 版本，默认启动自动溢出检查，运算溢出时会直接回滚交易；2、旧版本（<0.8）使用SafeMath库， 提供安全的加减乘除方法，溢出时自动回滚；3、手动检查边界条件；4、避免直接算术操作（对关键计算如代币转账、余额更新，强制使用安全函数）；总结：优先升级至Solidity0.8+，或结合使用SafeMath库与手动检验，测地杜绝算术风险。

- **如何理解solidity中的可见性关键字，并且它们的误用如何导致合约被攻击？**

Solidity中的可见性关键字（public、private、internal、external）定义了函数、变量的访问范围，误用可能导致严重的漏洞：1、public（允许合约内外调用）；2、external（仅允许外部调用，更节省Gas）；3、internal（仅限合约及其继承者访问）；4、private（仅限当前合约访问）；最佳实践：权限函数显式标记external或private，匿名默认public；敏感状态变量用private，但配合加密或权限控制；使用OpenZeppelin 的Ownable等库管理权限。所以可见性关键字是合约安全的“第一道门”，错误配置会直接暴露攻击面。

- **什么是委托调用（delegatecall）和它的风险？**

委托调用（delegatecall）是solidity中一种低级调用方式，允许一个合约借用另一个合约中的代码，但在自身上下文中执行（保持原始合约的存储、余额和地址）；特点是代码共享（复用目标合约的逻辑，无需重复部署）和存储不变（被调用代码修改的是调用者合约的存储，而非被调用者）；委托调用存在以下风险：1、存储冲突（若调用者与被调用者的变量存储布局不一致，可能导致数据被意外覆盖）；2、恶意合约攻击；3、权限混淆；4、Gas消耗不可控。总结：delegatecall功能强大但风险极高，必须严格审计存储和权限逻辑。

- **什么是交易顺序依赖性，它如何被利用进行攻击？**

交易顺序依赖性是指智能合约的执行结果因交易被打包进区块链的顺序不同而产生意外行为，由于以太坊矿工/验证者可以调整交易顺序，攻击者可能通过操纵交易排序获利。如何被利用进行攻击包括以下几点：1、抢跑攻击（攻击者监控内存池，发现有利交易后，支付更高Gas费抢先执行）；2、尾随攻击（攻击者跟随已知交易提交操作，例如在预言机更新价格后立即进行套利）；3、时间戳依赖（合约逻辑依赖区块时间戳，矿工可轻微调整时间戳影响结果）。防御措施包括：1、使用提交-揭示模式（用户先提交哈希承诺，稍后揭示真实数据，避免即时抢跑）；2、限制关键操作时间窗口（如设置订单有效期，减少可操纵时间）；避免链上随机数依赖交易顺序（改用链下随机数，如Chainlink VRF）。 总结：交易顺序是公链固有特性，合约设计需假设交易可能被抢跑，并通过机制降低风险。

- **在智能合约中如何安全地处理外部调用？**

- **如何利用以太坊的特性来增强智能合约的安全性？**

- **什么是智能合约中的拒绝服务（DOS）攻击？**

- **描述一种可能导致智能合约DOS攻击的情况？**

- **智能合约中的“所有者操作”是什么意思？它如何成为安全漏洞？**

- **Solidity中的block.timestamp可能导致哪些安全问题？**

- **构造函数在Solidity中的命名与漏洞有何关联？**

- **什么是未初始化的存储指针漏洞？它是如何影响智能合约？**

- **为什么在Solidity中不推荐使用tx.origin进行身份验证？**

- **Solidity不支持浮点数和定点数的后果是什么？**

- **什么是“一次性地址”技术，它如何在以太坊上被利用？**

- **描述如何在智能合约中防止未授权的修改或访问**

