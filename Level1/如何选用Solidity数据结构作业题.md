- **什么情况下应该使用 `uint` 或 `int` ?**

uint（无符号整数）和int（有符号整数）；Solidity中数组长度，address类型等底层均使用uint, 保持类型一致； 需要负数的场景或者外部数据接口返回带符号数据，就必须使用int。

- **如何选择存储以太坊地址使用的数据结构？**

使用address数据类型来存储以太坊地址，适用于用户钱包地址或合约地址；

- **在何时使用 `string` 与 `bytes` ？**

当存储可读文本或者长度不固定的长文本的时候，优先使用 `string`； 当处理哈希值、加密结果、原始字节码时，用`bytes`更高效。

- **数组在 Solidity 中的应用场景是什么？**

数组用于存储相同类型的元素列表， 可用于存储用户地址列表，ID集合等长度可变的数据或者长度固定的数据。

- **为何以及如何使用 `mapping` ？**

Solidity 中的 `mapping` 是一种高效的键值存储结构，用于快速查找和减少内存开销；基本用法示例：
```
mapping(keyType => valueType) public myMap
```
常用键名类型有 address/uint/byte32， 值类型可以是任意的; 应用场景如 代币余额、权限管理、投票记录等高频键值查询。

- **`struct` 的用途及实例**

`struct` 用于创建自定义的数据结构，将多个变量组合为逻辑单元，提升代码可读性和存储效率，
```
struct Person {
    string name;
    uint256 age;
}
```

- **何时使用`enum`及其好处是什么?**

`enum`（枚举）通常用于定义一组有限的命名常量，适用于需要明确状态或选项的场景： 1、当变量只能从预定义的一组值中取值时，比如状态管理：`enum orderStatus {Pending, shipped, Delivered, Cancelled }, orderStatus status` //仅允许枚举值； 2、用语义化名称替代硬编码数字 提升可读性；

使用`enum`有下列好处：1、类型安全（编译器会检查赋值是否合法，避免无效值）；2、节省`Gas`（枚举底层存储为`uint8`， 比字符串更高效）；3、提高代码可维护性（集中管理常量，修改时只需要调整枚举定义）；4、清晰表达意图（通过命名值直观地展示业务逻辑）；

枚举的使用场景优先级是：状态机>选项机制>魔法数字替换；合理使用`enum`能显著提升合约的安全性和可读性。

- **在设计合约时如何考虑存储和`Gas`成本？**

应该选择高效的数据结构来减少存储和执行成本；存储优化原则包含以下：1、最小化链上存储（将非关键数据移到IPFS或Arweave,链上仅存哈希 bytes32）； 2、紧凑变量打包（每个存储槽可合并多个小变量，并按变量大小降序排列 以自动打包）； 3、选择合适的数据类型（当为固定大小时优先选用bytes32 而不是string， 非负数值用uint 而不是int，避免符号位浪费空间）。

Gas成本控制有以下：1、减少存储操作（临时变量用memory替代storage处理中间数据，批量更新时合并多次写操作）；2、高效数据结构（用映射替代数组，mapping查询为O（1），适合高频访问 如余额检查， 用uint的位掩码存储多个布尔值）；3、循环与计算优化（限制循环次数，避免遍历动态数组）。

通过合理设计存储结构和算法，可以降低合约部署和交互成本达50%以上，尤其对高频调用的合约至关重要。

- **如何根据数据访问模式选择数据结构?**

在Solidity中，根据数据访问模式选择数据结构需要平衡 查询效率、存储成本和操作复杂度；1、高频查询，无需遍历，选择mapping，适合键值查找；2、需要变量或排序，使用动态数组，结合mapping记录索引；3、键值对+遍历需求，使用映射+数组组合，适用场景是需要同时支持遍历和单点查询；4、频繁增删数据使用链表模式；5、固定长度数据集使用固定大小数组；

通过匹配数据访问模式与结构特性，可显著降低Gas消耗并提升合约性能。

- **在复杂合约中选择数据结构的考虑因素有哪些？**

需要评估合约的功能需求，包括以下关键因素：1、访问模式（高频查询使用mapping，低频遍历用数组，增删改场景优先用链表或索引结构，纯查询用映射）；2、Gas效率（小数据类型 如uint8可能因slot对齐浪费空间，优先uint256）；3、数据规模（小数据集使用数组或结构体更直观，大数据集用链下存储（IPFS）+ 链上索引（bytes32哈希））；4、功能需求（结合mapping和排序数组进行分页排序，权限检查使用mapping快速验证）；5、升级与兼容性（代理合约中，数据结构需兼容未来升级，接口要符合ERC规范）；6、安全风险（溢出攻击（Solidity 0.8+默认检查，但复杂结构仍需边界验证），避免在遍历中调用外部合约）。

- **如何决定使用固定长度的数组还是动态数组？**

如果事先知道数组的最大长度，并且这个长度不会变化，使用固定长度大小的数组可以节省Gas成本；如果数组长度会动态变化应选用动态数组。原则是根据数据可变性与操作频率权衡选择，固定数组更高效，动态数组更灵活。

- **在`Solidity` 中使用 `mapping` 和`array` 的主要区别及使用场景是什么？**

区别由如下：`array`是`O（n）`遍历，线性查询，`mapping`是`O（1）`键值查找，极速；`array`是连续存储，包括空值，`mapping`仅存储非零值，默认值不占空间；

`mapping`适用于以下场景：1、高频键值查询、权限管理、稀疏数据。

`array`使用场景是：1、有序集合；2、遍历需求；3、固定长度数据；

混合优化方案，可以使用`mapping+array`组合，兼顾遍历与查询效率，适合需要排序或分页的场景。

- **如何利用`struct`在`solidity`中模拟传统的数据库表？**

在`solidity`中，通过`struct`结合`mapping`或数组可模拟传统数据库表，实现结构化数据存储与查询；以下步骤：1、定义数据表结构，`struct User {uint id; string name; uint balance; bool isActive}`, 每个struct字段对应表的列，如`id,name.balance`；2、存储方式可选择主键映射表，或者数组+映射索引（支持遍历）。

- **`solidity` 中 `enum` 如何帮助降低错误的发生？**

在`solidity`中，`enum`(枚举)通过以下机制显著降低代码错误风险：1、限制输入范围（预定义选项，强制变量仅能取枚举值，避免无效或越界数据）；2、替代魔法数字，语义化命名提升可读性，防止混淆；3.编译时检查（编译器会验证枚举值合法性，防止运行时意外赋值）；4、状态机验证（流程控制，明确状态转换规则，避免非法跳转）；总结 通过枚举将松散的数字约束为有限选项，是智能合约防御性编程的关键手段。

- **为何bytes类型有时比string更优？**

在以下场景中`bytes`比`string`更优：1、固定长度存储，`bytes32` 直接占用一个存储槽，而`string`需要动态分配内存，`Gas`成本更高；`bytes`的读写、比较和拼接消耗的`Gas`更少；2、二进制处理中，适合存储哈希值（bytes32），加密结果或原始字节码，避免`string`的编码开销，3、安全性增强方面，`byteN`固定长度可防止溢出攻击，而`string`需要手动检查边界，`string`设计`utf-8`编码，`bytes`直接处理二进制，避免意外字符错误；4、短文本如交易ID、地址缩写用`bytes32` 替代`string`节省空间； 总结：当处理二进制数据、固定长度内容或需要极致优化时，优先选择`bytes`，仅存储可变长度文本且需人类可读时使用`string`。

- **如何在`solidity`中存储时间的最佳数据结构？**

在`solidity`中，存储时间数据时，需要兼顾精度、`Gas`效率和易用性；1、首选`uint256`存储时间戳；2、若精度要求低，可使用`uint64`；3、复杂场景使用结构体；4、利用`solidity`的时间字面量（`seconds、minutes、days`）；5、避免`string`存储，会浪费存储且难以计算，前端将时间戳转换为可读日期，减少链上开销； 总结：简单场景使用`uint256`时间戳+`solidity`时间单位，复杂场景用结构体封装起止时间，极致优化时使用`uint64`降低存储成本。

- **在`solidity`合约中，何时应考虑将数据封装在`struct`内部？**

在`solidity`合约中，将数据封装在`struct`中的决策需要基于以下场景和优势：1、数据强关联时（当多个变量逻辑上属于统一实体，使用`struct`避免分散管理）；需节省存储成本时（通过紧凑布局 共享存储槽，减少`Gas`消耗）；3、复杂状态管理时（明确状态机转换，防止非法操作）；4、提升代码可读性时（用命名结构体替代魔法数字或松散变量，降低维护成本）；5、需要批量操作时（简化多参数传递，避免函数过长）；总结：当数据具有内在关联性、需节省存储或增强语义时，优先使用`struct`。

- **`mapping`类型是否支持迭代？如果不支持，如何解决？**

`solidity`中`mapping`不支持直接迭代，因为其设计为键值对存储，仅支持`(1)`的单点查询；如果需要支持有以下解决方案：1、维护独立键数组（新建数组存放所有键理）；2、使用`OpenZeppelin`的 `EnumerableMap`（内置迭代方法、自动处理键管）；3.使用链下索引（通过事件日志记录键变更，前端或服务端构建索引数据库）。

- **在设计一个包含多种资产类型的钱包合约时，应使用哪种数据结构？**

在设计支持多种资产类型（ETH、ERC20、NFT）的钱包合约时，推荐采用`嵌套映射+结构体`的组合结构：
```
struct Asset {
    uint256 ethBalance;
    mapping(address => uint256) erc20Balance;        //代币地址-余额
    mapping(address => EnumerableSet.UintSet) nfts;    //代币地址-NFT、ID集合
}
mapping(address => Asset) public userAsset;        //用户地址-资产
```
有以下优势：1、高效查询，O（1）访问任意资产；2、灵活扩展（支持动态添加代币、NFT类型）；3、节省Gas，仅存储非零余额，利用EnumerableSet 管理NFT ID。此方案平衡了存储成本、查询效率与可扩展性。

- **使用enum定义状态时，应如何处理状态的转换逻辑？**

在solidity中使用enum管理状态，应遵循以下规范：

1、显式状态校验（通过require严格限制转换路径，避免非法跳转）举例：
```
enum State {Created, Active, Closed}
State public state
function activate() external{
    require(state == State.Crated, "Invalid state!");
    state = State.Active;        // 仅允许 Created → Active
}
```；

2、集中化转换函数（封装状态修改逻辑，禁止直接赋值）；

3、事件日志（记录状态变更，便于追踪）；

4、使用状态机库（复杂场景使用OpenZeppelin的ConditionalEscrow 模版，避免重复造轮子）；

总结关键原则是：禁止跨状态转换，结合modifier复用校验逻辑。

